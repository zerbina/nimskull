preferName	ast/types.html#preferName	TPreferedDesc.preferName	
preferDesc	ast/types.html#preferDesc	TPreferedDesc.preferDesc	
preferExported	ast/types.html#preferExported	TPreferedDesc.preferExported	
preferModuleInfo	ast/types.html#preferModuleInfo	TPreferedDesc.preferModuleInfo	
preferGenericArg	ast/types.html#preferGenericArg	TPreferedDesc.preferGenericArg	
preferTypeName	ast/types.html#preferTypeName	TPreferedDesc.preferTypeName	
preferResolved	ast/types.html#preferResolved	TPreferedDesc.preferResolved	
preferMixed	ast/types.html#preferMixed	TPreferedDesc.preferMixed	
TPreferedDesc	ast/types.html#TPreferedDesc	types: TPreferedDesc	
base	ast/types.html#base,PType	types: base(t: PType): PType	
TTypeIter	ast/types.html#TTypeIter	types: TTypeIter	
TTypeMutator	ast/types.html#TTypeMutator	types: TTypeMutator	
TTypePredicate	ast/types.html#TTypePredicate	types: TTypePredicate	
paramsNotEqual	ast/types.html#paramsNotEqual	TParamsEquality.paramsNotEqual	
paramsEqual	ast/types.html#paramsEqual	TParamsEquality.paramsEqual	
paramsIncompatible	ast/types.html#paramsIncompatible	TParamsEquality.paramsIncompatible	
TParamsEquality	ast/types.html#TParamsEquality	types: TParamsEquality	
abstractPtrs	ast/types.html#abstractPtrs	types: abstractPtrs	
abstractVar	ast/types.html#abstractVar	types: abstractVar	
abstractRange	ast/types.html#abstractRange	types: abstractRange	
abstractInstOwned	ast/types.html#abstractInstOwned	types: abstractInstOwned	
skipPtrs	ast/types.html#skipPtrs	types: skipPtrs	
typedescPtrs	ast/types.html#typedescPtrs	types: typedescPtrs	
typedescInst	ast/types.html#typedescInst	types: typedescInst	
invalidGenericInst	ast/types.html#invalidGenericInst,PType	types: invalidGenericInst(f: PType): bool	
isPureObject	ast/types.html#isPureObject,PType	types: isPureObject(typ: PType): bool	
isUnsigned	ast/types.html#isUnsigned,PType	types: isUnsigned(t: PType): bool	
getOrdValue	ast/types.html#getOrdValue,PNode	types: getOrdValue(n: PNode; onError = high(Int128)): Int128	
getFloatValue	ast/types.html#getFloatValue,PNode	types: getFloatValue(n: PNode): BiggestFloat	
isIntLit	ast/types.html#isIntLit,PType	types: isIntLit(t: PType): bool	
isFloatLit	ast/types.html#isFloatLit,PType	types: isFloatLit(t: PType): bool	
elemType	ast/types.html#elemType,PType	types: elemType(t: PType): PType	
enumHasHoles	ast/types.html#enumHasHoles,PType	types: enumHasHoles(t: PType): bool	
isOrdinalType	ast/types.html#isOrdinalType,PType,bool	types: isOrdinalType(t: PType; allowEnumWithHoles: bool = false): bool	
iterOverType	ast/types.html#iterOverType,PType,TTypeIter,RootRef	types: iterOverType(t: PType; iter: TTypeIter; closure: RootRef): bool	
searchTypeFor	ast/types.html#searchTypeFor,PType,TTypePredicate	types: searchTypeFor(t: PType; predicate: TTypePredicate): bool	
containsObject	ast/types.html#containsObject,PType	types: containsObject(t: PType): bool	
frNone	ast/types.html#frNone	TTypeFieldResult.frNone	
frHeader	ast/types.html#frHeader	TTypeFieldResult.frHeader	
frEmbedded	ast/types.html#frEmbedded	TTypeFieldResult.frEmbedded	
TTypeFieldResult	ast/types.html#TTypeFieldResult	types: TTypeFieldResult	
analyseObjectWithTypeField	ast/types.html#analyseObjectWithTypeField,PType	types: analyseObjectWithTypeField(t: PType): TTypeFieldResult	
containsGarbageCollectedRef	ast/types.html#containsGarbageCollectedRef,PType	types: containsGarbageCollectedRef(typ: PType): bool	
containsManagedMemory	ast/types.html#containsManagedMemory,PType	types: containsManagedMemory(typ: PType): bool	
containsTyRef	ast/types.html#containsTyRef,PType	types: containsTyRef(typ: PType): bool	
containsHiddenPointer	ast/types.html#containsHiddenPointer,PType	types: containsHiddenPointer(typ: PType): bool	
isFinal	ast/types.html#isFinal,PType	types: isFinal(t: PType): bool	
canFormAcycle	ast/types.html#canFormAcycle,PType	types: canFormAcycle(typ: PType): bool	
mutateType	ast/types.html#mutateType,PType,TTypeMutator,RootRef	types: mutateType(t: PType; iter: TTypeMutator; closure: RootRef): PType	
bindConcreteTypeToUserTypeClass	ast/types.html#bindConcreteTypeToUserTypeClass.t,PType,PType	types: bindConcreteTypeToUserTypeClass(tc, concrete: PType)	
isResolvedUserTypeClass	ast/types.html#isResolvedUserTypeClass.t,PType	types: isResolvedUserTypeClass(t: PType): bool	
firstOrd	ast/types.html#firstOrd,ConfigRef,PType	types: firstOrd(conf: ConfigRef; t: PType): Int128	
firstFloat	ast/types.html#firstFloat,PType	types: firstFloat(t: PType): BiggestFloat	
lastOrd	ast/types.html#lastOrd,ConfigRef,PType	types: lastOrd(conf: ConfigRef; t: PType): Int128	
lastFloat	ast/types.html#lastFloat,PType	types: lastFloat(t: PType): BiggestFloat	
floatRangeCheck	ast/types.html#floatRangeCheck,BiggestFloat,PType	types: floatRangeCheck(x: BiggestFloat; t: PType): bool	
lengthOrd	ast/types.html#lengthOrd,ConfigRef,PType	types: lengthOrd(conf: ConfigRef; t: PType): Int128	
dcEq	ast/types.html#dcEq	TDistinctCompare.dcEq	
dcEqIgnoreDistinct	ast/types.html#dcEqIgnoreDistinct	TDistinctCompare.dcEqIgnoreDistinct	
dcEqOrDistinctOf	ast/types.html#dcEqOrDistinctOf	TDistinctCompare.dcEqOrDistinctOf	
TDistinctCompare	ast/types.html#TDistinctCompare	types: TDistinctCompare	
IgnoreTupleFields	ast/types.html#IgnoreTupleFields	TTypeCmpFlag.IgnoreTupleFields	
IgnoreCC	ast/types.html#IgnoreCC	TTypeCmpFlag.IgnoreCC	
ExactTypeDescValues	ast/types.html#ExactTypeDescValues	TTypeCmpFlag.ExactTypeDescValues	
ExactGenericParams	ast/types.html#ExactGenericParams	TTypeCmpFlag.ExactGenericParams	
ExactConstraints	ast/types.html#ExactConstraints	TTypeCmpFlag.ExactConstraints	
ExactGcSafety	ast/types.html#ExactGcSafety	TTypeCmpFlag.ExactGcSafety	
AllowCommonBase	ast/types.html#AllowCommonBase	TTypeCmpFlag.AllowCommonBase	
PickyCAliases	ast/types.html#PickyCAliases	TTypeCmpFlag.PickyCAliases	
TTypeCmpFlag	ast/types.html#TTypeCmpFlag	types: TTypeCmpFlag	
TTypeCmpFlags	ast/types.html#TTypeCmpFlags	types: TTypeCmpFlags	
sameType	ast/types.html#sameType,PType,PType,TTypeCmpFlags	types: sameType(a, b: PType; flags: TTypeCmpFlags = {}): bool	
sameTypeOrNil	ast/types.html#sameTypeOrNil,PType,PType,TTypeCmpFlags	types: sameTypeOrNil(a, b: PType; flags: TTypeCmpFlags = {}): bool	
equalParams	ast/types.html#equalParams,PNode,PNode	types: equalParams(a, b: PNode): TParamsEquality	
sameObjectTypes	ast/types.html#sameObjectTypes,PType,PType	types: sameObjectTypes(a, b: PType): bool	
sameDistinctTypes	ast/types.html#sameDistinctTypes,PType,PType	types: sameDistinctTypes(a, b: PType): bool	
sameEnumTypes	ast/types.html#sameEnumTypes,PType,PType	types: sameEnumTypes(a, b: PType): bool	
isGenericAlias	ast/types.html#isGenericAlias,PType	types: isGenericAlias(t: PType): bool	
skipGenericAlias	ast/types.html#skipGenericAlias,PType	types: skipGenericAlias(t: PType): PType	
sameFlags	ast/types.html#sameFlags,PType,PType	types: sameFlags(a, b: PType): bool	
sameBackendType	ast/types.html#sameBackendType,PType,PType	types: sameBackendType(x, y: PType): bool	
compareTypes	ast/types.html#compareTypes,PType,PType,TDistinctCompare,TTypeCmpFlags	types: compareTypes(x, y: PType; cmp: TDistinctCompare = dcEq;\n             flags: TTypeCmpFlags = {}): bool	
inheritanceDiff	ast/types.html#inheritanceDiff,PType,PType	types: inheritanceDiff(a, b: PType): int	
commonSuperclass	ast/types.html#commonSuperclass,PType,PType	types: commonSuperclass(a, b: PType): PType	
matchType	ast/types.html#matchType,PType,openArray[tuple[TTypeKind,int]],TTypeKind	types: matchType(a: PType; pattern: openArray[tuple[k: TTypeKind, i: int]];\n          last: TTypeKind): bool	
szUnknownSize	ast/types.html#szUnknownSize	types: szUnknownSize	
szIllegalRecursion	ast/types.html#szIllegalRecursion	types: szIllegalRecursion	
szUncomputedSize	ast/types.html#szUncomputedSize	types: szUncomputedSize	
szTooBigSize	ast/types.html#szTooBigSize	types: szTooBigSize	
foldSizeOf	ast/types.html#foldSizeOf.t,ConfigRef,PNode,PNode	types: foldSizeOf(conf: ConfigRef; n: PNode; fallback: PNode): PNode	
foldAlignOf	ast/types.html#foldAlignOf.t,ConfigRef,PNode,PNode	types: foldAlignOf(conf: ConfigRef; n: PNode; fallback: PNode): PNode	
foldOffsetOf	ast/types.html#foldOffsetOf.t,ConfigRef,PNode,PNode	types: foldOffsetOf(conf: ConfigRef; n: PNode; fallback: PNode): PNode	
computeSize	ast/types.html#computeSize,ConfigRef,PType	types: computeSize(conf: ConfigRef; typ: PType): BiggestInt	
getReturnType	ast/types.html#getReturnType,PSym	types: getReturnType(s: PSym): PType	
getAlign	ast/types.html#getAlign,ConfigRef,PType	types: getAlign(conf: ConfigRef; typ: PType): BiggestInt	
getSize	ast/types.html#getSize,ConfigRef,PType	types: getSize(conf: ConfigRef; typ: PType): BiggestInt	
containsGenericType	ast/types.html#containsGenericType,PType	types: containsGenericType(t: PType): bool	
baseOfDistinct	ast/types.html#baseOfDistinct,PType,ModuleGraph,IdGenerator	types: baseOfDistinct(t: PType; g: ModuleGraph; idgen: IdGenerator): PType	
safeInheritanceDiff	ast/types.html#safeInheritanceDiff,PType,PType	types: safeInheritanceDiff(a, b: PType): int	
compatibleEffects	ast/types.html#compatibleEffects,PType,PType	types: compatibleEffects(formal, actual: PType): EffectsCompat	
isCompileTimeOnly	ast/types.html#isCompileTimeOnly,PType	types: isCompileTimeOnly(t: PType): bool	
containsCompileTimeOnly	ast/types.html#containsCompileTimeOnly,PType	types: containsCompileTimeOnly(t: PType): bool	
safeSkipTypes	ast/types.html#safeSkipTypes,PType,TTypeKinds	types: safeSkipTypes(t: PType; kinds: TTypeKinds): PType	
NoneLike	ast/types.html#NoneLike	OrdinalType.NoneLike	
IntLike	ast/types.html#IntLike	OrdinalType.IntLike	
FloatLike	ast/types.html#FloatLike	OrdinalType.FloatLike	
OrdinalType	ast/types.html#OrdinalType	types: OrdinalType	
classify	ast/types.html#classify,PType	types: classify(t: PType): OrdinalType	
skipConv	ast/types.html#skipConv,PNode	types: skipConv(n: PNode): PNode	
skipHidden	ast/types.html#skipHidden,PNode	types: skipHidden(n: PNode): PNode	
skipConvTakeType	ast/types.html#skipConvTakeType,PNode	types: skipConvTakeType(n: PNode): PNode	
isEmptyContainer	ast/types.html#isEmptyContainer,PType	types: isEmptyContainer(t: PType): bool	
takeType	ast/types.html#takeType,PType,PType,ModuleGraph,IdGenerator	types: takeType(formal, arg: PType; g: ModuleGraph; idgen: IdGenerator): PType	
skipHiddenSubConv	ast/types.html#skipHiddenSubConv,PNode,ModuleGraph,IdGenerator	types: skipHiddenSubConv(n: PNode; g: ModuleGraph; idgen: IdGenerator): PNode	
getProcConvMismatch	ast/types.html#getProcConvMismatch,ConfigRef,PType,PType	types: getProcConvMismatch(c: ConfigRef; f, a: PType; rel = isNone): (\n    set[ProcConvMismatch], TTypeRelation)	
typeMismatch	ast/types.html#typeMismatch,ConfigRef,PType,PType	types: typeMismatch(conf: ConfigRef; formal, actual: PType): SemTypeMismatch	
typeMismatch	ast/types.html#typeMismatch,ConfigRef,set[TTypeKind],PType	types: typeMismatch(conf: ConfigRef; formal: set[TTypeKind]; actual: PType): SemTypeMismatch	
typeMismatch	ast/types.html#typeMismatch,ConfigRef,TLineInfo,PType,PType,PNode	types: typeMismatch(conf: ConfigRef; info: TLineInfo; formal, actual: PType; n: PNode): PNode	
semReportTypeMismatch	ast/types.html#semReportTypeMismatch,ConfigRef,PNode,,PType	types: semReportTypeMismatch(conf: ConfigRef; node: PNode;\n                      formal: PType | set[TTypeKind]; actual: PType): SemReport	
isTupleRecursive	ast/types.html#isTupleRecursive,PType	types: isTupleRecursive(t: PType): bool	
isException	ast/types.html#isException,PType	types: isException(t: PType): bool	
isDefectException	ast/types.html#isDefectException,PType	types: isDefectException(t: PType): bool	
isSinkTypeForParam	ast/types.html#isSinkTypeForParam,PType	types: isSinkTypeForParam(t: PType): bool	
lookupFieldAgain	ast/types.html#lookupFieldAgain,PType,PSym	types: lookupFieldAgain(ty: PType; field: PSym): PSym	
isCharArrayPtr	ast/types.html#isCharArrayPtr,PType,bool	types: isCharArrayPtr(t: PType; allowPointerToChar: bool): bool	
lacksMTypeField	ast/types.html#lacksMTypeField,PType	types: lacksMTypeField(typ: PType): bool	
